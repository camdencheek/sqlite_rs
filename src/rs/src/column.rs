use libc::{c_char, c_int, strlen};

use crate::global::{StdType, SQLITE_N_STDTYPE};

/*
** Information about each column of an SQL table is held in an instance
** of the Column structure, in the Table.aCol[] array.
**
** Definitions:
**
**   "table column index"     This is the index of the column in the
**                            Table.aCol[] array, and also the index of
**                            the column in the original CREATE TABLE stmt.
**
**   "storage column index"   This is the index of the column in the
**                            record BLOB generated by the OP_MakeRecord
**                            opcode.  The storage column index is less than
**                            or equal to the table column index.  It is
**                            equal if and only if there are no VIRTUAL
**                            columns to the left.
**
** Notes on zCnName:
** The zCnName field stores the name of the column, the datatype of the
** column, and the collating sequence for the column, in that order, all in
** a single allocation.  Each string is 0x00 terminated.  The datatype
** is only included if the COLFLAG_HASTYPE bit of colFlags is set and the
** collating sequence name is only included if the COLFLAG_HASCOLL bit is
** set.
*/
#[repr(C)]
pub struct Column {
    /// Name of this column
    // NOTE: this might have a type name stored after the null
    // terminator, so treating this as a normal c string is not safe.
    zCnName: *mut c_char,

    /// An OE_ code for handling a NOT NULL constraint
    // TODO: merge notNull and eCType into a single 8-bit field
    notNull: u8,

    /// One of the standard types. Or zero if not a standard type.
    eCType: u8,

    /// One of the SQLITE_AFF_... values
    pub affinity: c_char,

    /// Est size of value in this column. sizeof(INT)==1
    szEst: u8,

    /// Column name hash for faster lookup
    hName: u8,

    /// 1-based index of DEFAULT. 0 means "none"
    iDflt: u16,

    /// Boolean properties. See COLFLAG_ defines below
    pub colFlags: u16,
}

impl Column {
    /// Return the declared type of the column, or None if the column has no declared type.
    ///
    /// The column type is an extra string stored after the zero-terminator on the column name if
    /// and only if the COLFLAG_HASTYPE flag is set.
    pub unsafe fn std_type(&self) -> Option<*const c_char> {
        if self.colFlags & Colflag::Hastype as u16 != 0 {
            Some(self.zCnName.add(strlen(self.zCnName) + 1))
        } else if self.eCType != 0 {
            debug_assert!(self.eCType <= SQLITE_N_STDTYPE);
            Some(StdType::from_u8(self.eCType).unwrap().name().as_ptr())
        } else {
            None
        }
    }
}

/// Return the declared type of a column.  Or return zDflt if the column
/// has no declared type.
#[no_mangle]
pub unsafe extern "C" fn sqlite3ColumnType(col: &mut Column, default: *mut c_char) -> *mut c_char {
    if let Some(z) = col.std_type() {
        // TODO: we are sometimes returning static strings from this,
        // so it can't always be mut. Figure out whether it's safe
        // to change the return value to a const
        z as *mut i8
    } else {
        default
    }
}

/* Allowed values for Column.eCType.
**
** Values must match entries in the global constant arrays
** sqlite3StdTypeLen[] and sqlite3StdType[].  Each value is one more
** than the offset into these arrays for the corresponding name.
** Adjust the SQLITE_N_STDTYPE value if adding or removing entries.
*/
#[repr(C)]
pub enum Coltype {
    Custom = 0,
    Any = 1,
    Blob = 2,
    Int = 3,
    Integer = 4,
    Real = 5,
    Text = 6,
}

/* Allowed values for Column.colFlags.
**
** Constraints:
**         TF_HasVirtual == COLFLAG_VIRTUAL
**         TF_HasStored  == COLFLAG_STORED
**         TF_HasHidden  == COLFLAG_HIDDEN
*/
#[repr(C)]
pub enum Colflag {
    Primkey = 0x0001,   /* Column is part of the primary key */
    Hidden = 0x0002,    /* A hidden column in a virtual table */
    Hastype = 0x0004,   /* Type name follows column name */
    Unique = 0x0008,    /* Column def contains "UNIQUE" or "PK" */
    Sorterref = 0x0010, /* Use sorter-refs with this column */
    Virtual = 0x0020,   /* GENERATED ALWAYS AS ... VIRTUAL */
    Stored = 0x0040,    /* GENERATED ALWAYS AS ... STORED */
    Notavail = 0x0080,  /* STORED column not yet calculated */
    Busy = 0x0100,      /* Blocks recursion on GENERATED columns */
    Hascoll = 0x0200,   /* Has collating sequence name in zCnName */
    Noexpand = 0x0400,  /* Omit this column when expanding "*" */
    Generated = 0x0060, /* Combo: _STORED, _VIRTUAL */
    Noinsert = 0x0062,  /* Combo: _HIDDEN, _STORED, _VIRTUAL */
}

/*
** The SQLITE_AFF_MASK values masks off the significant bits of an
** affinity value.
*/
pub const SQLITE_AFF_MASK: c_int = 0x47;

/*
** Additional bit values that can be ORed with an affinity without
** changing the affinity.
**
** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.
** It causes an assert() to fire if either operand to a comparison
** operator is NULL.  It is added to certain comparison operators to
** prove that the operands are always NOT NULL.
*/
pub const SQLITE_JUMPIFNULL: c_int = 0x10; /* jumps if either operand is NULL */
pub const SQLITE_NULLEQ: c_int = 0x80; /* NULL=NULL */
pub const SQLITE_NOTNULL: c_int = 0x90; /* Assert that operands are never NULL */
