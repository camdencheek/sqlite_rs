use libc::{c_char, c_int};

/*
** Information about each column of an SQL table is held in an instance
** of the Column structure, in the Table.aCol[] array.
**
** Definitions:
**
**   "table column index"     This is the index of the column in the
**                            Table.aCol[] array, and also the index of
**                            the column in the original CREATE TABLE stmt.
**
**   "storage column index"   This is the index of the column in the
**                            record BLOB generated by the OP_MakeRecord
**                            opcode.  The storage column index is less than
**                            or equal to the table column index.  It is
**                            equal if and only if there are no VIRTUAL
**                            columns to the left.
**
** Notes on zCnName:
** The zCnName field stores the name of the column, the datatype of the
** column, and the collating sequence for the column, in that order, all in
** a single allocation.  Each string is 0x00 terminated.  The datatype
** is only included if the COLFLAG_HASTYPE bit of colFlags is set and the
** collating sequence name is only included if the COLFLAG_HASCOLL bit is
** set.
*/
#[repr(C)]
pub struct Column {
    zCnName: *mut c_char, /* Name of this column */

    // TODO: merge notNull and eCType into a single 8-bit field
    notNull: u8, /* An OE_ code for handling a NOT NULL constraint */
    eCType: u8,  /* One of the standard types */

    affinity: c_char, /* One of the SQLITE_AFF_... values */
    szEst: u8,        /* Est size of value in this column. sizeof(INT)==1 */
    hName: u8,        /* Column name hash for faster lookup */
    iDflt: u16,       /* 1-based index of DEFAULT.  0 means "none" */
    colFlags: u16,    /* Boolean properties.  See COLFLAG_ defines below */
}

/* Allowed values for Column.eCType.
**
** Values must match entries in the global constant arrays
** sqlite3StdTypeLen[] and sqlite3StdType[].  Each value is one more
** than the offset into these arrays for the corresponding name.
** Adjust the SQLITE_N_STDTYPE value if adding or removing entries.
*/
#[repr(C)]
pub enum Coltype {
    Custom = 0,
    Any = 1,
    Blob = 2,
    Int = 3,
    Integer = 4,
    Real = 5,
    Text = 6,
}

pub const SQLITE_N_STDTYPE: u8 = 6; /* Number of standard types */

/* Allowed values for Column.colFlags.
**
** Constraints:
**         TF_HasVirtual == COLFLAG_VIRTUAL
**         TF_HasStored  == COLFLAG_STORED
**         TF_HasHidden  == COLFLAG_HIDDEN
*/
#[repr(C)]
pub enum Colflag {
    Primkey = 0x0001,   /* Column is part of the primary key */
    Hidden = 0x0002,    /* A hidden column in a virtual table */
    Hastype = 0x0004,   /* Type name follows column name */
    Unique = 0x0008,    /* Column def contains "UNIQUE" or "PK" */
    Sorterref = 0x0010, /* Use sorter-refs with this column */
    Virtual = 0x0020,   /* GENERATED ALWAYS AS ... VIRTUAL */
    Stored = 0x0040,    /* GENERATED ALWAYS AS ... STORED */
    Notavail = 0x0080,  /* STORED column not yet calculated */
    Busy = 0x0100,      /* Blocks recursion on GENERATED columns */
    Hascoll = 0x0200,   /* Has collating sequence name in zCnName */
    Noexpand = 0x0400,  /* Omit this column when expanding "*" */
    Generated = 0x0060, /* Combo: _STORED, _VIRTUAL */
    Noinsert = 0x0062,  /* Combo: _HIDDEN, _STORED, _VIRTUAL */
}

/*
** Column affinity types.
**
** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER and
** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improve
** the speed a little by numbering the values consecutively.
**
** But rather than start with 0 or 1, we begin with 'A'.  That way,
** when multiple affinity types are concatenated into a string and
** used as the P4 operand, they will be more readable.
**
** Note also that the numeric types are grouped together so that testing
** for a numeric type is a single comparison.  And the BLOB type is first.
*/
#[repr(C)]
pub enum SqliteAff {
    None = 0x40,    /* '@' */
    Blob = 0x41,    /* 'A' */
    Text = 0x42,    /* 'B' */
    Numeric = 0x43, /* 'C' */
    Integer = 0x44, /* 'D' */
    Real = 0x45,    /* 'E' */
    Flexnum = 0x46, /* 'F' */
}

/*
** The SQLITE_AFF_MASK values masks off the significant bits of an
** affinity value.
*/
pub const SQLITE_AFF_MASK: c_int = 0x47;

/*
** Additional bit values that can be ORed with an affinity without
** changing the affinity.
**
** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.
** It causes an assert() to fire if either operand to a comparison
** operator is NULL.  It is added to certain comparison operators to
** prove that the operands are always NOT NULL.
*/
pub const SQLITE_JUMPIFNULL: c_int = 0x10; /* jumps if either operand is NULL */
pub const SQLITE_NULLEQ: c_int = 0x80; /* NULL=NULL */
pub const SQLITE_NOTNULL: c_int = 0x90; /* Assert that operands are never NULL */
